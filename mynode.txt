“这个问题与虚拟地址空间的分配规则有关，每一个可执行C程序，从低地址到高地址依次是：text，data，bss，堆，栈，环境参数变量；
其中堆和栈之间有很大的地址空间空闲着，在需要分配空间的时候，堆向上涨，栈往下涨。”

这样设计可以使得堆和栈能够充分利用空闲的地址空间。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，
但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。所以就可能出现这种情况：
一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，
最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化！！


（1）identification [4, 1, 1, 1, 9]
第一部分：占四个字节。

    7f 45 4c 46，应读为 4c 46 45 7f，对应ASCII码 ELF.，表示这是一个ELF对象。

第二部分：占一个字节。

    02 表示是一个64位对象。

第三部分：占一个字节。

    01 表示是小端表示法。

第四部分：占一个字节。

    01 表示文件头版本。

其余默认为0。

（2）information [2, 2, 4, 8, 8, 8, 4, 2, 2, 2, 2, 2, 2]
